## 盛最多水的容器



给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

 ![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg) 

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int maxArea=0;
        int area;
        int i=0;
        for(;i<height.size();i++)
        {
            for(int j=i;j<height.size();j++)
            {
                int min=(height[i]>height[j])?height[j]:height[i];
                area=(j-i)*min;
                if(area>maxArea)
                    maxArea=area;
            
            }
        }
        return maxArea;
    }
};
```

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left=0,right=height.size()-1;
         int maxArea=0,area;  
        while(left<right)
        {
            if(height[left]<height[right])
                {
                    area=(right-left)*height[left];
                    left++;
                    if(area>maxArea)
                        maxArea=area;
                    
                }
            else 
            {
                    area=(right-left)*height[right];
                    right--;
                    if(area>maxArea)
                        maxArea=area;
            }
                
        }
            
        
        return maxArea;
    }

};
```

>
>
>关键是,一开始在两边,每次两边中小的那个往中间移,寻求突破,因为虽然二者距离小了,但是有可能变大
>
>大的那个移动是没有收益的,因为他不是限制高度的那个短板,反而会因为移动减少二者之间的距离