# [80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
       
        if(nums.size()<3) return nums.size();
        int res = 2;
        for(int i=2;i<nums.size();i++){
            if(nums[i]!=nums[res-2])
                nums[res++] = nums[i];
        }
        return res;
    }
};
```

### 滑动窗口



1维护一个长为3的窗口，如果窗口头尾元素不相等，则说明窗头元素重复度小于等于2，符合要求，更新数组
1.　特判　数组长度小于3　return
2. pos 为数组更新位置
3. left,right 为窗口头尾
4. 遍历数组，如果头尾元素不等，更新nums[pos] = nums[left],pos += 1
5. 窗口右移，left+=1,right+=1
6. 注意　由于right先到结尾，所以最后两个元素没有判定，分析知数组最后两个元素一定符合要求，更新nums[pos]

```java
class Solution:
    def removeDuplicates(self, nums) -> int:
        if len(nums) < 3:
            return len(nums)
        pos = left = 0
        right = 2
        while right < len(nums):
            if nums[right] != nums[left]:
                nums[pos] = nums[left]
                pos += 1
            left += 1
            right += 1
        nums[pos] = nums[-2]
        nums[pos + 1] = nums[-1]
        return pos + 2

作者：alice-37
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shuang-zhi-zhen-hua-dong-chuang-kou-shi-jian-on-ko/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### 写入点 + 遍历点 思路

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/xie-ru-dian-bian-li-dian-si-lu-by-yuhhen/)

一般这类题都使用双指针遍历来减少暴力法的重复计算次数

如果用人类的思维来理解计算机的执行，你可以想象有一排麻将/扑克/whatever，你的目标是按次序将最多2张一样的牌放入新数组
 你的左手（慢指针）指着目前需要放牌的位置，右手（快指针）挨个儿去找目标值的牌，找到后把牌放入左手的位置，不满足就后跳，直到找到下一张（这里在程序里应该有一个while，但是和外层可以合并优化）

因为数组是排序的，所以很容易理解右手掠过的牌的位置，我们是可以直接覆盖的，所以不需要一个新数组，直接原位替换即可

放牌的位置很好确定，直接每次递增即可，**难点就在如何选定下一张牌的位置**

对于已经放入牌组的数值，有下面两种情况：

1. A B
2. A A

很容易发现第三张牌必须是 B 或 C 或其他值时，才能被选中，那么我们发现**右手指向的牌面值，必须与前第二张的值不同，才可以被选中**
 所以可以从索引2开始，按照上面的方法让两个指针同时遍历，这样可以很容易处理左边界情况，也符合人类的思维。

```C++

public class Solution {
    public int RemoveDuplicates(int[] nums) {
        var len = nums.Length;
        if(len <= 2) {
            return len;
        }
        var i=2;
        var j=2;

        while(j < len) {
            if(nums[j] != nums[i-2]) {
                nums[i] = nums[j];
                i++;
            }
            j++;
        }

        return i;
    }
}
```