#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。

**示例:** 

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

**进阶:**

如果你已经完成了*O*(*n*) 时间复杂度的解法, 请尝试 *O*(*n* log *n*) 时间复杂度的解法。

>>
>>
>>执行结果：
>>
>>通过
>>
>>显示详情 
>>
>>执行用时 :8 ms, 在所有 C++ 提交中击败了95.37% 的用户
>>
>>内存消耗 :12.6 MB, 在所有 C++ 提交中击败了5.46%的用户
>
>
>
>right 是下一个要插入的
>
>//ACMer
>
>for(; ;)
>{
>/*
>分三步,第一步,往右,直到到顶或者大于S
>	  第二步,判断是不是大于S,如果没有大于S,说明没资格大于S了
>	  第三步,试着看看左边移动能不能缩减距离
>*/
>
>}
>
>

```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
       int left=0,right=0,res=nums.size()+1,sum=0;
       for(;;)
       {
           while(right<nums.size()&&sum<s)
           {
               sum+=nums[right];
               right++;
           }
            if(sum<s)
                break;
            while(left<right&&sum>=s)
            {
                if(right-left<res)
                    res=right-left;
                sum-=nums[left];
                left++;
            }
      
       }
         if(res>nums.size())
            res=0;
        return res;

    }
};
```











```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        if(nums.size()==0)
            return 0;
        int min;
        
        for(int left=0,right=nums.size()-1;left<nums.size();left++)
        {
            if(nums[left]>=s)
            {
                return 1;
            }
          
            int temp=nums[left];
            int count=1;
            while(left+count<=right&&temp<s)
            {
                               
                temp+=nums[left+count];                
                count++;
                
            }
            if(left==0)
            {
                if(temp<s)
                    return 0;
                min=count;
            }
                
            if(temp>=s&&left<=right)
            {
                if(count<min)
                    min=count;
            }

        }
        return min;


    }
};
```

>执行结果：
>
>通过
>
>显示详情 
>
>执行用时 :348 ms, 在所有 C++ 提交中击败了12.33% 的用户
>
>内存消耗 :12.5 MB, 在所有 C++ 提交中击败了5.46%的用户

```
// 牛逼阿 我自己想出来的 滑动窗口
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        if(nums.size()==0)
            return 0;
        int windows=1;
        for(;windows<=nums.size();windows++)
        {
        int left=0,right=windows-1;
        int sum=0;
        for(int i=0;i<windows;i++)
        {
            sum+=nums[left+i];
        }
         if(sum>=s)
                     return windows;
        while(right<nums.size()-1)           
            {
                sum-=nums[left++];
                sum+=nums[++right];
                if(sum>=s)
                     return windows;
                  
            }
       
         }
        
        return 0;
    }
};
```

```
//滑动窗口
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
       if(nums.size()==0)
            return 0;
        int left=0,right=0,sum=0,size=nums.size()+1;
        while(left<nums.size()-1)
        {
            
            if(sum<s)
            {
                
                if(right<=nums.size()-1)
                    sum+=nums[right];
                if(right<nums.size())
                    right++;
                else 
                {
                    if(size==nums.size()+1)
                        return 0;
                    else 
                        return size;
                }
                    
                
              
               
            }
            else
            {               
                if(right-left<size)
                    size=right-left;
                sum-=nums[left];
                left++;
            }

        }
        return size;

    }
};
```

